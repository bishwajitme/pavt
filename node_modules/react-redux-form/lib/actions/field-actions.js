'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _actionTypes = require('../action-types');

var _actionTypes2 = _interopRequireDefault(_actionTypes);

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var focus = function focus(model) {
  return {
    type: _actionTypes2.default.FOCUS,
    model: model
  };
};

var blur = function blur(model) {
  return {
    type: _actionTypes2.default.BLUR,
    model: model
  };
};

var setPristine = function setPristine(model) {
  return {
    type: _actionTypes2.default.SET_PRISTINE,
    model: model
  };
};

var setDirty = function setDirty(model) {
  return {
    type: _actionTypes2.default.SET_DIRTY,
    model: model
  };
};

var setInitial = function setInitial(model) {
  return {
    type: _actionTypes2.default.SET_INITIAL,
    model: model
  };
};

var setPending = function setPending(model) {
  var pending = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_PENDING,
    model: model,
    pending: pending
  };
};

var setValidity = function setValidity(model, validity) {
  return {
    type: _actionTypes2.default.SET_VALIDITY,
    model: model,
    validity: validity
  };
};

var setErrors = function setErrors(model, errors) {
  return {
    type: _actionTypes2.default.SET_ERRORS,
    model: model,
    errors: errors
  };
};

var setTouched = function setTouched(model) {
  return {
    type: _actionTypes2.default.SET_TOUCHED,
    model: model
  };
};

var setUntouched = function setUntouched(model) {
  return {
    type: _actionTypes2.default.SET_UNTOUCHED,
    model: model
  };
};

var asyncSetValidity = function asyncSetValidity(model, validator) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);

    dispatch(setPending(model, true));

    var done = function done(validity) {
      dispatch(setValidity(model, validity));
      dispatch(setPending(model, false));
    };

    var immediateResult = validator(value, done);

    if (typeof immediateResult !== 'undefined') {
      done(immediateResult);
    }
  };
};

var setSubmitted = function setSubmitted(model) {
  var submitted = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_SUBMITTED,
    model: model,
    submitted: submitted
  };
};

var setViewValue = function setViewValue(model, value) {
  return {
    type: _actionTypes2.default.SET_VIEW_VALUE,
    model: model,
    value: value
  };
};

var submit = function submit(model, promise) {
  return function (dispatch) {
    dispatch(setPending(model, true));

    promise.then(function (response) {
      dispatch(setSubmitted(model, true));
      dispatch(setValidity(model, response));
    }).catch(function (error) {
      dispatch(setPending(model, false));
      dispatch(setErrors(model, error));
    });
  };
};

var validate = function validate(model, validators) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);
    var validity = (0, _utils.getValidity)(validators, value);

    dispatch(setValidity(model, validity));
  };
};

exports.default = {
  asyncSetValidity: asyncSetValidity,
  blur: blur,
  focus: focus,
  submit: submit,
  setDirty: setDirty,
  setErrors: setErrors,
  setInitial: setInitial,
  setPending: setPending,
  setPristine: setPristine,
  setSubmitted: setSubmitted,
  setTouched: setTouched,
  setUntouched: setUntouched,
  setValidity: setValidity,
  setViewValue: setViewValue,
  validate: validate
};