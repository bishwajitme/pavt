'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFieldClass = exports.controlPropsMap = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _connect = require('react-redux/lib/components/connect');

var _connect2 = _interopRequireDefault(_connect);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _capitalize = require('lodash/capitalize');

var _capitalize2 = _interopRequireDefault(_capitalize);

var _compose = require('redux/lib/compose');

var _compose2 = _interopRequireDefault(_compose);

var _identity = require('lodash/identity');

var _identity2 = _interopRequireDefault(_identity);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _mapValues = require('lodash/mapValues');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _partial = require('lodash/partial');

var _partial2 = _interopRequireDefault(_partial);

var _actions2 = require('../actions');

var _actions3 = _interopRequireDefault(_actions2);

var _controlComponent = require('./control-component');

var _controlComponent2 = _interopRequireDefault(_controlComponent);

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var asyncSetValidity = _actions3.default.asyncSetValidity;
var blur = _actions3.default.blur;
var change = _actions3.default.change;
var focus = _actions3.default.focus;
var setValidity = _actions3.default.setValidity;
var toggle = _actions3.default.toggle;
var xor = _actions3.default.xor;


function selector(state, _ref) {
  var model = _ref.model;

  return {
    model: model,
    modelValue: (0, _get3.default)(state, model)
  };
}

var controlPropsMap = {
  default: function _default(props) {
    return controlPropsMap.text(props);
  },
  checkbox: function checkbox(props) {
    return _extends({
      name: props.model,
      checked: function () {
        if ((0, _utils.isMulti)(props.model)) {
          return (props.modelValue || []).filter(function (item) {
            return (0, _isEqual2.default)(item, props.value);
          }).length;
        }

        return !!props.modelValue;
      }()
    }, props);
  },
  radio: function radio(props) {
    return _extends({
      name: props.model,
      checked: (0, _isEqual2.default)(props.modelValue, props.value),
      value: props.value
    }, props);
  },
  select: function select(props) {
    return _extends({
      name: props.model,
      value: props.modelValue
    }, props);
  },
  text: function text(props) {
    return _extends({
      defaultValue: props.modelValue,
      name: props.model
    }, props);
  },
  textarea: function textarea(props) {
    return controlPropsMap.text(props);
  }
};

function changeMethod(model, value) {
  var action = arguments.length <= 2 || arguments[2] === undefined ? change : arguments[2];
  var parser = arguments.length <= 3 || arguments[3] === undefined ? _identity2.default : arguments[3];

  return (0, _compose2.default)((0, _partial2.default)(action, model), parser, _utils.getValue);
}

function isReadOnlyValue(control) {
  return control.type === 'input' // verify === is okay
   && ~['radio', 'checkbox'].indexOf(control.props.type);
}

var controlActionMap = {
  checkbox: function checkbox(props) {
    return (0, _utils.isMulti)(props.model) ? xor : toggle;
  },
  default: function _default() {
    return change;
  }
};

function getControlType(control, options) {
  var _controlPropsMap = options.controlPropsMap;


  try {
    var controlDisplayName = control.constructor.displayName || control.type.displayName || control.type.name || control.type; // what was the + '' for? tests pass without it

    if (controlDisplayName === 'input') {
      controlDisplayName = _controlPropsMap[control.props.type] ? control.props.type : 'text';
    }

    return _controlPropsMap[controlDisplayName] ? controlDisplayName : null;
  } catch (error) {
    return undefined;
  }
}

function sequenceEventActions(control, props) {
  var dispatch = props.dispatch;
  var model = props.model;
  var updateOn = props.updateOn;


  var updateOnEventHandler = typeof updateOn === 'function' ? 'onChange' : 'on' + (0, _capitalize2.default)(props.updateOn || 'change');
  var validateOn = 'on' + (0, _capitalize2.default)(props.validateOn || 'change');
  var asyncValidateOn = 'on' + (0, _capitalize2.default)(props.asyncValidateOn || 'blur');

  var updaterFn = typeof updateOn === 'function' ? updateOn : _identity2.default;

  var eventActions = {
    onFocus: [function () {
      return dispatch(focus(model));
    }],
    onBlur: [function () {
      return dispatch(blur(model));
    }],
    onChange: []
  };

  var controlAction = (controlActionMap[control.props.type] || controlActionMap.default)(props);

  var controlChangeMethod = changeMethod(model, props.value, controlAction, props.parser);

  var dispatchChange = undefined;
  if (control.props.hasOwnProperty('value') && isReadOnlyValue(control)) {
    dispatchChange = function dispatchChange() {
      return dispatch(controlChangeMethod(control.props.value));
    };
  } else {
    dispatchChange = function dispatchChange(event) {
      return dispatch(controlChangeMethod(event));
    };
  }

  eventActions[updateOnEventHandler].push(updaterFn(dispatchChange));

  if (props.validators) {
    var dispatchValidate = function dispatchValidate(value) {
      var validity = (0, _utils.getValidity)(props.validators, value);

      dispatch(setValidity(model, validity));

      return value;
    };

    eventActions[validateOn].push(dispatchValidate);
  }

  if (props.asyncValidators) {
    var dispatchAsyncValidate = function dispatchAsyncValidate(value) {
      (0, _mapValues2.default)(props.asyncValidators, function (validator, key) {
        return dispatch(asyncSetValidity(model, function (_, done) {
          var outerDone = function outerDone(valid) {
            return done(_defineProperty({}, key, valid));
          };

          validator((0, _utils.getValue)(value), outerDone);
        }));
      });

      return value;
    };

    eventActions[asyncValidateOn].push(dispatchAsyncValidate);
  }

  return (0, _mapValues2.default)(eventActions, function (_actions) {
    return _compose2.default.apply(undefined, _toConsumableArray(_actions));
  });
}

function createFieldProps(control, props, options) {
  var model = props.model;
  var modelValue = props.modelValue;

  var controlType = getControlType(control, options);

  var _controlPropsMap = options.controlPropsMap;


  if (!controlType) {
    return false;
  }

  return _extends({}, _controlPropsMap[controlType](_extends({
    model: model,
    modelValue: modelValue
  }, control.props, sequenceEventActions(control, props, options))));
}

function createFieldControlComponent(control, props, options) {
  if (!control || !control.props || Object.hasOwnProperty(control.props, 'modelValue')) {
    return control;
  }

  var controlProps = createFieldProps(control, props, options);

  if (!controlProps) {
    return _react2.default.cloneElement(control, {
      children: _react2.default.Children.map(control.props.children, function (child) {
        return createFieldControlComponent(child, _extends({}, props, child.props), options);
      })
    });
  }

  /* eslint-disable react/prop-types */
  // TODO: Track down where to set correct propType for modelValue
  return _react2.default.createElement(_controlComponent2.default, _extends({}, controlProps, { modelValue: props.modelValue, control: control }));
  /* eslint-enable react/prop-types */
}

function getFieldWrapper(props) {
  if (props.component) {
    return props.component;
  }

  if (props.className || props.children.length > 1) {
    return 'div';
  }

  return null;
}

function createFieldClass() {
  var customControlPropsMap = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var options = {
    controlPropsMap: _extends({}, controlPropsMap, customControlPropsMap)
  };

  var Field = function (_Component) {
    _inherits(Field, _Component);

    function Field() {
      _classCallCheck(this, Field);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Field).apply(this, arguments));
    }

    _createClass(Field, [{
      key: 'render',
      value: function render() {
        var props = this.props;

        var component = getFieldWrapper(props);

        if (component) {
          return _react2.default.createElement(component, props, _react2.default.Children.map(props.children, function (child) {
            return createFieldControlComponent(child, props, options);
          }));
        }

        return createFieldControlComponent(_react2.default.Children.only(props.children), props, options);
      }
    }]);

    return Field;
  }(_react.Component);

  Field.propTypes = {
    model: _react.PropTypes.string.isRequired,
    component: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string]),
    parser: _react.PropTypes.func,
    updateOn: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.oneOf(['change', 'blur', 'focus'])]),
    validators: _react.PropTypes.object,
    asyncValidators: _react.PropTypes.object,
    validateOn: _react.PropTypes.string,
    asyncValidateOn: _react.PropTypes.string
  };

  return (0, _connect2.default)(selector)(Field);
}

exports.controlPropsMap = controlPropsMap;
exports.createFieldClass = createFieldClass;
exports.default = createFieldClass(controlPropsMap);